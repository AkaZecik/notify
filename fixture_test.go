package notify

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/rjeczalik/fs"
	"github.com/rjeczalik/fs/fsutil"
	"github.com/rjeczalik/fs/memfs"
)

func nonil(err ...error) error {
	for _, err := range err {
		if err != nil {
			return err
		}
	}
	return nil
}

func watch(w Watcher, e Event) filepath.WalkFunc {
	return walkfn(w, func(w Watcher, p string) error { return w.Watch(p, e) })
}

func unwatch(w Watcher) filepath.WalkFunc {
	return walkfn(w, Watcher.Unwatch)
}

func walkfn(w Watcher, fn func(Watcher, string) error) filepath.WalkFunc {
	return func(p string, fi os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if fi.IsDir() {
			err = fn(w, p)
		}
		return err
	}
}

// Tree was autogenerated by github.com/rjeczalik/fs/cmd/gotree - DO NOT EDIT
// BY HAND.
//
// It represents the following directory tree:
//
//   .
//   └── github.com
//       └── rjeczalik
//           ├── fakerpc
//           │   ├── LICENSE
//           │   ├── README.md
//           │   ├── appveyor.yml
//           │   ├── cli
//           │   │   └── cli.go
//           │   ├── cmd
//           │   │   └── fakerpc
//           │   │       └── main.go
//           │   ├── fakerpc.go
//           │   ├── fakerpc_test.go
//           │   ├── fixture.go
//           │   ├── ngrep.go
//           │   ├── ngrep_test.go
//           │   ├── proxy.go
//           │   ├── proxy_test.go
//           │   ├── server.go
//           │   └── util.go
//           ├── fs
//           │   ├── LICENSE
//           │   ├── README.md
//           │   ├── appveyor.yml
//           │   ├── cmd
//           │   │   ├── gotree
//           │   │   │   ├── go.go
//           │   │   │   └── main.go
//           │   │   └── mktree
//           │   │       └── main.go
//           │   ├── fs.go
//           │   ├── fsutil
//           │   │   ├── fixture_test.go
//           │   │   ├── fsutil.go
//           │   │   ├── fsutil_test.go
//           │   │   ├── rel.go
//           │   │   ├── rel_test.go
//           │   │   ├── tee.go
//           │   │   └── tee_test.go
//           │   └── memfs
//           │       ├── memfs.go
//           │       ├── memfs_test.go
//           │       ├── tree.go
//           │       ├── tree_test.go
//           │       ├── util.go
//           │       └── util_test.go
//           └── which
//               ├── LICENSE
//               ├── README.md
//               ├── appveyor.yml
//               ├── cmd
//               │   ├── gofile
//               │   │   └── main.go
//               │   └── gowhich
//               │       └── main.go
//               ├── testdata
//               │   ├── cmd
//               │   │   └── echo
//               │   │       └── echo.go
//               │   ├── darwin_386
//               │   │   └── echo
//               │   ├── darwin_amd64
//               │   │   └── echo
//               │   ├── freebsd_386
//               │   │   └── echo
//               │   ├── freebsd_amd64
//               │   │   └── echo
//               │   ├── linux_386
//               │   │   └── echo
//               │   ├── linux_amd64
//               │   │   └── echo
//               │   ├── windows_386
//               │   │   └── echo.exe
//               │   └── windows_amd64
//               │       └── echo.exe
//               ├── which.go
//               ├── which_elf.go
//               ├── which_macho.go
//               ├── which_pe.go
//               └── which_test.go
//
//   27 directories, 53 files
var tree = memfs.Must(memfs.UnmarshalTab([]byte(".\n\tgithub.com\n\t\trj" +
	"eczalik\n\t\t\tfakerpc\n\t\t\t\tLICENSE\n\t\t\t\tREADME.md\n\t\t\t\tappv" +
	"eyor.yml\n\t\t\t\tcli\n\t\t\t\t\tcli.go\n\t\t\t\tcmd\n\t\t\t\t\tfakerpc\n" +
	"\t\t\t\t\t\tmain.go\n\t\t\t\tfakerpc.go\n\t\t\t\tfakerpc_test.go\n\t\t\t" +
	"\tfixture.go\n\t\t\t\tngrep.go\n\t\t\t\tngrep_test.go\n\t\t\t\tproxy.go\n" +
	"\t\t\t\tproxy_test.go\n\t\t\t\tserver.go\n\t\t\t\tutil.go\n\t\t\tfs\n\t\t" +
	"\t\tLICENSE\n\t\t\t\tREADME.md\n\t\t\t\tappveyor.yml\n\t\t\t\tcmd\n\t\t\t" +
	"\t\tgotree\n\t\t\t\t\t\tgo.go\n\t\t\t\t\t\tmain.go\n\t\t\t\t\tmktree\n\t" +
	"\t\t\t\t\tmain.go\n\t\t\t\tfs.go\n\t\t\t\tfsutil\n\t\t\t\t\tfixture_test" +
	".go\n\t\t\t\t\tfsutil.go\n\t\t\t\t\tfsutil_test.go\n\t\t\t\t\trel.go\n\t" +
	"\t\t\t\trel_test.go\n\t\t\t\t\ttee.go\n\t\t\t\t\ttee_test.go\n\t\t\t\tme" +
	"mfs\n\t\t\t\t\tmemfs.go\n\t\t\t\t\tmemfs_test.go\n\t\t\t\t\ttree.go\n\t\t" +
	"\t\t\ttree_test.go\n\t\t\t\t\tutil.go\n\t\t\t\t\tutil_test.go\n\t\t\twhi" +
	"ch\n\t\t\t\tLICENSE\n\t\t\t\tREADME.md\n\t\t\t\tappveyor.yml\n\t\t\t\tcm" +
	"d\n\t\t\t\t\tgofile\n\t\t\t\t\t\tmain.go\n\t\t\t\t\tgowhich\n\t\t\t\t\t\t" +
	"main.go\n\t\t\t\ttestdata\n\t\t\t\t\tcmd\n\t\t\t\t\t\techo\n\t\t\t\t\t\t" +
	"\techo.go\n\t\t\t\t\tdarwin_386\n\t\t\t\t\t\techo\n\t\t\t\t\tdarwin_amd6" +
	"4\n\t\t\t\t\t\techo\n\t\t\t\t\tfreebsd_386\n\t\t\t\t\t\techo\n\t\t\t\t\t" +
	"freebsd_amd64\n\t\t\t\t\t\techo\n\t\t\t\t\tlinux_386\n\t\t\t\t\t\techo\n" +
	"\t\t\t\t\tlinux_amd64\n\t\t\t\t\t\techo\n\t\t\t\t\twindows_386\n\t\t\t\t" +
	"\t\techo.exe\n\t\t\t\t\twindows_amd64\n\t\t\t\t\t\techo.exe\n\t\t\t\twhi" +
	"ch.go\n\t\t\t\twhich_elf.go\n\t\t\t\twhich_macho.go\n\t\t\t\twhich_pe.go" +
	"\n\t\t\t\twhich_test.go\n")))

// ntree is a sum of tree's items (dirs + files).
const ntree = 80

// IsDir reports whether p points to a directory. A path that ends with a trailing
// path separator are assumed to be a directory.
func IsDir(p string) bool {
	return strings.HasSuffix(p, sep)
}

// Fixture maps event types and actions which are invoked on user-specified
// EventInfo values.
type FixtureFunc map[Event]func(path string) error

// Fixture is a default set of actions for Create, Delete, Write and Move events.
var fixture = FixtureFunc{
	Create: func(p string) error {
		if IsDir(p) {
			return os.MkdirAll(p, 0755)
		}
		f, err := os.Create(p)
		if err != nil {
			return err
		}
		return f.Close()

	},
	Delete: func(p string) error {
		return os.RemoveAll(p)
	},
	Write: func(p string) error {
		f, err := os.OpenFile(p, os.O_RDWR, 0755)
		if err != nil {
			return err
		}
		fi, err := f.Stat()
		if err != nil {
			f.Close()
			return err
		}
		if fi.IsDir() {
			panic("invalid EventInfo exec: " + p)
		}
		_, err = f.WriteString(p)
		if err != nil {
			f.Close()
			return err
		}
		return f.Close()
	},
	Move: func(p string) error {
		return os.Rename(p, p+".moved")
	},
}

// Fixture mixes given fixture function map with the default fixture.
//
// When len(f) == 0 it returns a copy of fixture variable.
//
// The returned fixture is a copy to ensure no global variable is modified by
// a test.
func Fixture(f FixtureFunc) FixtureFunc {
	for s, fn := range fixture {
		f[s] = fn
	}
	return f
}

// Cases dumps Tree into unique temporary location on the filesystem. It returns
// a control structures which is used for performing various testing over temportary
// directory tree.
func (f FixtureFunc) Cases(t *testing.T) (cas Cases) {
	assert := func(err ...error) {
		for _, err := range err {
			if err != nil {
				t.Fatalf("unexpected fixture failure: %v", err)
			}
		}
	}
	dir, err := ioutil.TempDir("", "notify")
	assert(err)
	if n := fsutil.Copy(tree, fsutil.Rel(fs.Default, dir)); n != ntree {
		t.Fatalf("unexpected fixture mktree failure: want n=%d; got %d", ntree, n)
	}
	cas.t = t
	cas.path = func(s string) string {
		return filepath.Join(dir, filepath.FromSlash(s))
	}
	cas.walk = func(fn filepath.WalkFunc) error {
		return fsutil.Rel(tree, dir).Walk(sep, fn)
	}
	cas.exec = func(ei EventInfo) error {
		fn, ok := f[ei.Event()]
		if !ok {
			return fmt.Errorf("unexpected fixture failure: invalid Event=%v", ei.Event())
		}
		if err := fn(join(dir, ei.Name())); err != nil {
			return fmt.Errorf("want err=nil; got %v (ei=%+v)", err, ei)
		}
		return nil
	}
	cas.clean = func() {
		assert(os.RemoveAll(dir))
	}
	return
}

func join(base, name string) (p string) {
	p = filepath.Join(base, filepath.FromSlash(name))
	if name[len(name)-1] == '/' {
		p = p + sep
	}
	return
}

type testev struct {
	e Event
	p string
	b bool
}

func (v testev) Event() Event     { return v.e }
func (v testev) IsDir() bool      { return v.b }
func (v testev) Name() string     { return v.p }
func (v testev) Sys() interface{} { return nil }

// Ev gives new EventInfo for p path, e Event and b saying if it's a directory.
func EI(p string, e Event) EventInfo {
	return testev{
		p: p,
		e: e,
		b: IsDir(p),
	}
}

func equal(lhs, rhs EventInfo) error {
	lhse, lhsp, lhsb := lhs.Event(), lhs.Name(), lhs.IsDir()
	rhse, rhsp, rhsb := rhs.Event(), rhs.Name(), rhs.IsDir()
	// TODO(rjeczalik): Get tmpdir from the fixture, join here and compare
	// full paths.
	// Take into account lhsb, rhsb (not taken because of fsnotify for delete).
	if lhse != rhse || !strings.HasSuffix(filepath.Clean(lhsp), filepath.Clean(rhsp)) {
		return fmt.Errorf("want EventInfo{Event: %v, Name: %s, IsDir: %v}; "+
			"got EventInfo{Event: %v, Name: %s, IsDir:%v}", rhse, rhsp, rhsb,
			lhse, lhsp, lhsb)
	}
	return nil
}

// Global timeout used for a single test.
var timeout = time.Second

// Cases TODO
type Cases struct {
	t     *testing.T
	path  func(string) string
	walk  func(filepath.WalkFunc) error
	exec  func(EventInfo) error
	clean func()
}

// ExpectEvents watches events described by e within Watcher given by the w and
// executes in order events described by ei.
//
// It immadiately fails and stops if either expected event was not received or
// the time test took has exceeded default global timeout.
func (cas Cases) ExpectEvents(w Watcher, e Event, ei []EventInfo) {
	done, c, stop := make(chan error), make(chan EventInfo, len(ei)), make(chan struct{})
	defer func() {
		err := cas.walk(unwatch(w))
		close(stop)
		cas.clean()
		if err != nil {
			cas.t.Fatal(err)
		}
	}()
	w.Fanin(c, stop)
	if err := cas.walk(watch(w, e)); err != nil {
		cas.t.Fatal(err)
	}
	go func() {
		for _, ei := range ei {
			if err := cas.exec(ei); err != nil {
				done <- err
				return
			}
			if err := equal(<-c, ei); err != nil {
				done <- err
				return
			}
		}
		done <- nil
	}()
	select {
	case <-time.After(timeout):
		cas.t.Fatalf("test has timed out after %v", timeout)
	case err := <-done:
		if err != nil {
			cas.t.Fatal(err)
		}
	}
}

// ExpectEventList TODO
func (cas Cases) ExpectEventList(w Watcher, e Event, ei map[EventInfo][]Event) {
	done, c, stop := make(chan error), make(chan EventInfo, len(ei)), make(chan struct{})
	defer func() {
		err := cas.walk(unwatch(w))
		close(stop)
		cas.clean()
		if err != nil {
			cas.t.Fatal(err)
		}
	}()
	w.Fanin(c, stop)
	if err := cas.walk(watch(w, e)); err != nil {
		cas.t.Fatal(err)
	}
	go func() {
		for ei, evs := range ei {
			if err := cas.exec(ei); err != nil {
				done <- err
				return
			}
			for _, ev := range evs {
				if ev&e == 0 {
					continue
				}
				got := <-c
				if got.Event() == ei.Event() {
					if err := equal(got, ei); err != nil {
						done <- err
						return
					}
				} else {
					if got.Event() != ev {
						done <- fmt.Errorf(
							"got invalid event %v, want %v", got.Event(), ev)
						return
					}
				}
			}
		}
		done <- nil
	}()
	select {
	case <-time.After(timeout):
		cas.t.Fatalf("test has timed out after %v", timeout)
	case err := <-done:
		if err != nil {
			cas.t.Fatal(err)
		}
	}
}
